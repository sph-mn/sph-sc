#!/usr/bin/guile
!#

(import (sph common) (sph lang sc) (only (guile) read) (sph stream) (sph conditional) (sph cli))

(define (process input-port output-port)
  (display
    (sc->c (pair (q begin) (stream->list (port->stream input-port read)))
      (pair
        (ensure-trailing-slash
          (if-pass (port-filename input-port) (l (a) (path->full-path (dirname a))) (getcwd)))
        sc-default-load-paths))
    output-port))

(define (each-input-file proc paths)
  (each (l (path) (call-with-input-file path (l (a) (set-port-filename! a path) (proc a)))) paths))

(define* (sc #:optional paths-source path-destination) "appends multiple sources"
  (if path-destination
    (call-with-output-file path-destination
      (l (file-destination)
        (if paths-source
          (each-input-file (l (source-file) (process source-file file-destination)) paths-source)
          (process (current-input-port) file-destination))))
    (if paths-source
      (each-input-file (l (source-file) (process source-file (current-output-port))) paths-source)
      (process (current-input-port) (current-output-port)))))

(let
  (options
    ( (cli-create #:help
        (string-join
          (list
            "compiles sc to c. uses standard input/output or files, depending on how many paths have been given."
            "no path: read from standard input and write to standard output"
            "one path: read from standard input and write to standard output"
            "two or more paths: read from all leading paths and write to the last path")
          "\n")
        #:options (list-q ((source-path ... destination-path)) ((source-path))))))
  (alist-bind options (source-path destination-path)
    (sc (if-pass source-path any->list) destination-path)))
