#!/usr/bin/guile
!#

(import (sph) (sph filesystem)
  (sph list) (sph alist)
  (sph lang sc) (only (guile) read) (sph stream) (srfi srfi-1) (sph conditional) (sph cli))

(define (process input-port output-port)
  (display
    (sc->c (pair (q begin) (stream->list (port->stream input-port read)))
      (pair
        (ensure-trailing-slash
          (if-pass (port-filename input-port) (l (a) (path->full-path (dirname a))) (getcwd)))
        sc-default-load-paths))
    output-port))

(define (each-input-file proc paths)
  (each (l (path) (call-with-input-file path (l (a) (set-port-filename! a path) (proc a)))) paths))

(define* (sc #:optional paths-source path-destination) "appends multiple sources"
  (if path-destination
    (call-with-output-file path-destination
      (l (file-destination)
        (if (null? paths-source) (process (current-input-port) file-destination)
          (each-input-file (l (source-file) (process source-file file-destination)) paths-source))))
    (if (null? paths-source) (process (current-input-port) (current-output-port))
      (each-input-file (l (source-file) (process source-file (current-output-port))) paths-source))))

(let
  (options
    ( (cli-create #:help
        (string-join
          (list
            "compiles sc to c. uses standard input/output or files, depending on how many paths have been given."
            "no path: read from standard input and write to standard output"
            "one path: read from standard input and write to standard output"
            "two or more paths: read from all leading paths and write to the last path")
          "\n")
        #:options (ql ((source-path ... destination-path)) ((source-path))))))
  (alist-bind options (source-path destination-path) (sc (any->list source-path) destination-path)))
