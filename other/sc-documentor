#!/usr/bin/guile
!#

(define sph-sc-documentor-cli-description
  "extracts declarations for types, functions, macros and variables from sc files and
   displays elements as c declarations in an overview in markdown format")

(define sph-sc-documentor-description
  "command-line interface: sc-documentor --help
   # data structures
   sc-doc-elements: (sc-doc-element ...)
   sc-doc-element: (symbol:type any ...)
   # extractors
   extractors match sc expression list-prefixes and return an sc-doc-element,
   for example \"(routine name parameters output-type input-type)\".
   there is no user extension mechanism yet. new extractors must be added to \"extractors\".
   new sc-doc-element types can be used but sc-format-group would
   have to be extended to recognise them")

(import (sph) (sph stream)
  (ice-9 match) (sph lang sc expressions)
  (sph alist) (sph list) (sph cli) (sph list one) (sph lang sc) (sph string) (rnrs sorting))

(define (extract-enum a) (list (pair (q enum) a)))

(define (extract-define a) "-> (routine name parameters output-type input-type)"
  (match a
    ( ( ( (? not-preprocessor-keyword? name) parameter ...)
        ((? not-function-pointer-symbol? return-type) types ...) body ...)
      (list (list (q routine) name parameter return-type types)))
    ( ( ( (? not-preprocessor-keyword? name)) return-type body ...)
      (list (list (q routine) name null return-type null)))
    ((name type value) (list (list (q variable) name type))) (else #f)))

(define (extract-declare-type a) "-> (type symbol:other/struct/union/function name [value])"
  (match a
    ((name ((quote function-pointer) body ...)) (list (q type) (q function) name (second a)))
    ((name ((quote struct) body ...)) (list (q type) (q struct) name (second a)))
    ((name ((quote union) body ...)) (list (q type) (q union) name (second a)))
    ((name _ ...) (list (q type) (q other) name))))

(define (extract-declare-array a) "-> (array name type (integer ...))"
  (match a
    ((name type size values ...) (let (size (any->list size)) (list (q array) name type size)))))

(define (extract-declare a)
  "-> sc-doc-elements
   sc-doc-elements contains any of the following sc-doc-element types
     routine, type, (variable name output-type), (enum names ...),
     (struct name fields), (union name fields)"
  (map-slice 2
    (l (id type)
      (match type (((quote array) a ...) (extract-declare-array (pair id a)))
        (((quote enum) a ...) (first (extract-enum a)))
        ( ( (or (quote struct) (quote union)) (not (? symbol?)) _ ...)
          (list (first type) id (second type)))
        (((quote type) type) (extract-declare-type (pair id type)))
        (_ (let (b (extract-define (list id type))) (if b (first b) (list (q variable) id type))))))
    a))

(define (extract-pre-define a) "-> ((macro name list:parameters) ...)"
  (if (= 1 (length a)) (list (list (q macro) a null))
    (map-slice 2
      (l (name value)
        (match name ((name parameter ...) (list (q macro) name parameter))
          (_ (list (q macro) name null))))
      a)))

(define-as extractors alist-q
  ;pre-define extract-pre-define
  ;define extract-define enum extract-enum
  declare extract-declare)

(define (extract-one a)
  "list -> sc-doc-elements
   take an sc expression and try to extract documentation relevant information
   using prefixes and procedures defined in \"extractors\""
  (any
    (l (extractor)
      (and (not (null? a)) (eq? (first extractor) (first a)) ((tail extractor) (tail a))))
    extractors))

(define (extract-from-file path) "string -> sc-doc-elements"
  (stream-fold
    (l (result a) (let (matched (extract-one a)) (if matched (append result matched) result))) null
    (file->stream path read)))

(define (extract-from-files-combined paths)
  "extract from multiple files and display a merged result" (append-map extract-from-file paths))

(define-as group-order list-q type enum routine macro variable)

(define (group-title id)
  (case id
    ((type) "# types")
    ((enum) "# enum")
    ((routine) "# routines")
    ((macro) "# macros")
    ((variable) "# variables")))

(define (format-group-type a) "format an sc-doc-element group for declared c types"
  (apply append
    (filter-map
      (l (sub-type)
        (and-let* ((sub-group (alist-ref a sub-type)))
          (map
            (l (a)
              (case sub-type
                ((other) (sc-identifier (first a)))
                ( (function)
                  (let
                    (a
                      (string-split
                        (string-drop-prefix "typedef " (sc->c (pair (q define-type) a))) #\())
                    (string-append (first a) " (" (string-join (tail a) "("))))
                ( (struct union)
                  (string-append (sc-identifier (first a)) " "
                    (let
                      ((a (sc->c (second a))) (type (if (eq? (q union) sub-type) "union" "struct")))
                      (string-trim-right
                        (string-append type "\n  "
                          (string-join
                            (string-split
                              (string-trim-both (string-trim-both (string-drop-prefix type a) #\{)
                                #\})
                              #\;)
                            ";\n  "))))))))
            (list-sort-with-accessor string<? (compose symbol->string first)
              (map (compose tail tail) sub-group)))))
      (list-q other function union struct))))

(define (format-group id a)
  (if (eq? (q type) id) (format-group-type a)
    (list-sort string<?
      (map
        (l (a)
          (case id
            ( (routine)
              (apply
                (l (name parameters type-out type-in)
                  (string-append (sc-identifier type-out) " "
                    (sc-identifier name) "("
                    (if (null? parameters) ""
                      (string-join
                        (map (l (a b) (string-append (sc-identifier a) " " (sc-identifier b)))
                          type-in parameters)
                        ", "))
                    ")"))
                (tail a)))
            ( (macro)
              (apply
                (l (name parameters)
                  (string-append (sc-identifier name)
                    (if (null? parameters) ""
                      (string-append "(" (string-join (map sc-identifier parameters) ", ") ")"))))
                (tail a)))
            ( (variable)
              (apply (l (name type) (string-append (sc-identifier type) " " (sc-identifier name)))
                (tail a)))
            ( (enum)
              (string-join (map-slice 3 (l a (string-join (map sc-identifier a) ", ")) (second a))
                ",\n"))))
        a))))

(define additions null)
(define exclusions null)
(define identifier-replacements null)

(define (extracted-identifier-replace a identifier-replacements)
  "(string:regexppattern string:replacement [string:pattern string:replacement] ...)
   replace any identifier by regexp"
  (let
    (replace
      (let
        (b
          (map (l (a) (pair (make-regexp (first a)) (tail a)))
            (list->alist identifier-replacements)))
        (l (a)
          (if (symbol? a)
            (string->symbol
              (fold (l (b result) (regexp-replace result (first b) (tail b))) (symbol->string a) b))
            a))))
    (map
      (l (a)
        (case (first a)
          ( (macro)
            (apply (l (name parameters) (list (q macro) (replace name) (map replace parameters)))
              (tail a)))
          ( (routine)
            (apply
              (l (name parameters type-out type-in)
                (list (q routine) (replace name)
                  (map replace parameters) (replace type-out) (map replace type-in)))
              (tail a)))
          ( (variable)
            (apply (l (name type-out) (list (q variable) (replace name) (replace type-out)))
              (tail a)))
          ( (type)
            (pair (first a)
              (match (tail a)
                ( ( (quote struct) name ((quote struct) struct-body ...))
                  (list (q struct) name
                    (pair (q struct)
                      (map (l (a) (pairs (first a) (replace (second a)) (tail (tail a))))
                        struct-body))))
                (else (tail a)))))
          (else a)))
      a)))

(define (extracted-exclude a exclusions) "(string:regexp-pattern)"
  (let
    (exclusions?
      (let (exclusions (map make-regexp exclusions))
        (l (a) "string -> booloean" (any (l (b) (regexp-exec b a)) exclusions))))
    (filter
      (l (a)
        (let
          (name
            (case (first a)
              ((macro variable routine) (symbol->string (second a)))
              ((type) (symbol->string (list-ref a 2)))
              (else #f)))
          (not (and name (exclusions? name)))))
      a)))

(define (sc-documentor-cli)
  (let*
    ( (options
        ( (cli-create #:options
            (list-q ((sc-file-path ...) #:required? #t #:value-required? #t)
              (config #:value-required? #t))
            #:description sph-sc-documentor-cli-description)))
      (extracted
        ; -> ((extracted-element-type _ ...) ...)
        (begin (and-let* ((config (alist-ref-q options config))) (load config))
          (append (apply append (filter-map extract-one additions))
            (extract-from-files-combined (alist-ref-q options sc-file-path)))))
      (extracted
        (extracted-identifier-replace (extracted-exclude extracted exclusions)
          identifier-replacements))
      (grouped (group extracted first)))
    (display-line
      (string-join
        (filter-map
          (l (group-id)
            (and-let*
              ((a (alist-ref grouped group-id)) (a (if (eq? (q type) group-id) (group a second) a)))
              (string-append (group-title group-id) "\n"
                "```c\n" (string-join (format-group group-id a) "\n") "\n```")))
          group-order)
        "\n\n"))))

(sc-documentor-cli)
